# NSA-Remaster

졸업 작품으로 제작했던 캐릭터 수집형 디펜스 게임입니다.   
2017년 JAVA로 제작했던 게임을 Unity엔진을 사용하여 리마스터링했습니다.   
해당 프로젝트 링크 : [NSA Original Project](https://github.com/chocoPenguin/LSA)

## 🎮프로젝트 소개
![Alt text](https://user-images.githubusercontent.com/43777949/193440036-02372b8f-68e7-4a4a-a9f6-d6c7e4c572df.png)
> 📌 **게임 장르**: 캐릭터 수집형 2D 디펜스 게임   
> 📌 **플랫폼**: PC   
> 📌 **제작 인원**: 1인   
> 📌 **제작 기간**: 2달+@   
> 📌 **사용 엔진과 언어**: Unity, C#   

## 🎮게임 컨셉
![게임 컨셉1](https://user-images.githubusercontent.com/43777949/193538773-4c944a59-7bfa-4ddb-86c2-6c0d5d6f68b6.png)   
![게임 컨셉2](https://user-images.githubusercontent.com/43777949/193538841-6d470d0f-4f7c-46a7-9b9a-42aa245543db.png)   
2050년의 대한민국에서는, 알코올 중독자가 전체 인구의 30%를 넘었다.   
이에 따라 대한민국 정부는 주류 유통 및 판매 금지법을 개시했다.   
이를 막기 위해 술들은 단합하여 전국 술 협회, NSA를 설립하는데...   
   
## 🎮프로젝트 구조
### 1. GameManager
> * 싱글턴 패턴. 모든 씬에서 사용하는 유저 데이터, 전체 캐릭터 리스트가 변수로 선언되어있으며, json파일 읽기/쓰기, 씬 이동 등의 함수를 구현했습니다.   
### 2. 데이터
> * 유저 데이터와 캐릭터 목록은 그 목적과 사용이 다른 스크립트와 다르기 때문에 구별하여 다른 폴더에 저장했습니다.   
### 3. 프로젝트
> ![스크립트 분류](https://user-images.githubusercontent.com/43777949/193543043-19eb9f85-af51-4296-aee4-8b471bf9fad3.png)   
> * 데이터(유저, 캐릭터 목록)를 제외한 스크립트들은 각각의 씬마다 분류해두었습니다.   
> * 스크립트와 함수, 변수의 이름은 최대한 직관적으로 이것의 역할이 무엇인지, 무엇을 나타내는 값인지 알아볼 수 있도록 설정했습니다.   
> * 필요할 경우 '_(언더바)'를 활용하여 변수 구분을 하거나 가독성을 높였고, 변수들은 소문자, 함수들은 대문자로 시작하여 구분지었습니다.   
> * 스테이지의 경우 스크립트가 많아 그 안에서도 적, 아군 타워, 스테이지 기능으로 구분해두었습니다.   
### 4. 코드와 디자인 패턴
> * Update()의 부하를 줄이고, 비동기 프로그래밍의 효과를 주기 위해 대부분의 함수를 코루틴으로 구현했습니다.   
> * 1번에서 언급했다시피 GameManager라는 싱글턴 패턴을 사용하여 모든 씬에서 공통적으로 사용하는 함수와 데이터를 모아두었습니다.
   
## 🎮플레이
### 플레이 전체 동영상
유튜브 링크: ㅁㄹㄴ   

**이하는 gif를 사용한 설명입니다.**


### 1. 신규 계정 생성
<img src="https://user-images.githubusercontent.com/43777949/193462757-eda2cec2-6b49-4b84-ad82-1a1767a55687.gif" width="100%"/>
게임에 진입을 하여 START 버튼을 눌렀을 경우, 만약 로컬 경로에 저장된 유저 데이터가 없다면 신규 계정 생성을 진행합니다.
닉네임을 입력하면 새로운 계정이 로컬에 **json 파일**로 생성됩니다.
이후, 유저 데이터가 있는 상태에서 게임을 실행하면 해당 씬은 실행되지 않고 바로 홈화면으로 이동하게 됩니다.
      
### 1.1. 프롤로그
<img src="https://user-images.githubusercontent.com/43777949/193462848-7f5823e4-64fa-4e3c-bd8a-b15fbfc726f5.gif" width="100%"/>   
신규 계정을 생성했을 때만 진행되는 씬으로, 간략한 프롤로그를 보여줍니다.
**csv 파일**에 저장된 대사를 읽어와 **List에 저장**하고 이를 순서대로 출력합니다.   
한 글자씩 보여주는 타이핑 효과를 위해 **코루틴을 사용**했습니다.
한 대사가 모두 출력되었다면 마우스 클릭을 통해 다음 대사로 이동할 수 있습니다.   
      
### 2. 홈화면
<img src="https://user-images.githubusercontent.com/43777949/193558048-35bf9f8c-bdf9-47e2-9fb5-2906eb3dfc94.jpg" width="100%"/>   
홈 화면에서는 여러 씬으로 이동할 수 있습니다.   
      
### 2.1. 뽑기
<img src="https://user-images.githubusercontent.com/43777949/193462887-b2e49c86-5dd0-41ee-9aaa-b9cdbe0f4f20.gif" width="100%"/>   
충분한 재화가 존재할 경우, 뽑기 버튼을 누를 경우 지정된 확률에 따라 뽑기를 진행합니다.   
뽑기 결과는 유저가 보유한 캐릭터 리스트와 비교하여 최초 획득일 경우에는 리스트에 삽입하고, 중복일 경우 스킵합니다.   
유저의 캐릭터 리스트는 *List 자료구조*를 사용하였습니다.   
삭제는 이루어지지 않으며, 삽입만이 존재하고, 리스트의 중간에 삽입하는 과정이 없기 때문에 List 자료구조를 채택했습니다.   
또한 캐릭터 획득 시 기본적으로 캐릭터 고유 ID에 따라 **정렬**될 수 있도록 하였습니다.
      
### 2.2. 뽑기 재화 부족
<img src="https://user-images.githubusercontent.com/43777949/193463055-3fdef886-f30f-4f91-81b0-5cef154b1de2.gif" width="100%"/>   
만약 뽑기에 필요한 재화가 부족하다면 '재화가 부족합니다' 경고가 출력됩니다.   
**코루틴을 사용**하여 천천히 페이드아웃되는 효과를 주었습니다.   
  
### 3. 상점
<img src="https://user-images.githubusercontent.com/43777949/193463093-272c72d6-3f52-4e7d-af56-36f3ed5416e1.gif" width="100%"/>   
상점에서는 가지고 있는 재화를 사용하여 다른 재화를 구매할 수 있습니다.   
재화의 목록은 **스크롤뷰를 사용하여 이후 유기적으로 추가**할 수 있게 했습니다.   
구매에 필요한 재화가 있다면 성공적으로 구매가 가능하고, 만약 재화가 부족하다면 뽑기와 마찬가지로 **코루틴을 사용한 경고창**이 떴다 페이드아웃되며 사라집니다.   
   
### 4. 캐릭터 목록
<img src="https://user-images.githubusercontent.com/43777949/193464839-1f357a24-fe6e-4320-ab0d-e29e3dbd7223.gif" width="100%"/>   
가지고 있는 캐릭터 목록을 확인할 수 있습니다.   
**스크롤뷰**를 사용하여 캐릭터 목록이 출력되며, 캐릭터를 클릭할 경우 상세 정보를 확인할 수 있습니다.

### 5. 편성
<img src="https://user-images.githubusercontent.com/43777949/193463173-2b856f13-8b41-4b07-bf19-d313767de50e.gif" width="100%"/>   
편성창에서는 가지고 있는 캐릭터를 덱에 편성할 수 있습니다.   
덱 또한 **List 자료구조**를 사용하였으며 덱이 수정될 때마다 유저 정보에 자동으로 저장됩니다.   
네 칸 중 어느 위치에 넣어도 **앞으로 정렬**될 수 있도록 하여 List에서 오류가 발생하지 않도록 했습니다.

### 6.1. 스테이지 진입
<img src="https://user-images.githubusercontent.com/43777949/193464714-b25c82b9-9daa-42b7-921b-ab61546e2c9f.gif" width="100%"/>   
스테이지 버튼을 누르면 현재 유저의 덱 정보를 확인할 수 있습니다.   
편성창과 마찬가지로 이곳에서도 덱을 수정할 수 있습니다.   
우측 상단의 출발 버튼을 누르면 스테이지 진입이 가능합니다.   
유저의 선택한 덱의 정보는 **DontDestroyOnLoad**를 사용하여 씬을 전환하여도 보존되며, 이를 바탕으로 우측 하단에 현재 유저의 덱에 존재하는
타워들을 나열합니다.   
이 과정이 끝난다면 덱 정보가 저장된 **오브젝트는 파괴**되어 메모리를 줄이도록 했습니다.

### 6.2. 편성 인원 부족
<img src="https://user-images.githubusercontent.com/43777949/193463455-d8acab0c-197e-4df1-bccc-129697cdd48c.gif" width="100%"/>   
만약 편성 인원이 0명이라면 인원 부족 경고창이 출력되며 스테이지로 진입할 수 없습니다.
      
### 6.3 타워 배치
<img src="https://user-images.githubusercontent.com/43777949/193463429-3f66b166-66d4-4ba6-b040-84706b7b9bd6.gif" width="100%"/>   
우측 하단의 타워 그림을 드래그하여 타워를 배치할 수 있습니다.
타워가 배치되면 해당 타워의 코스트만큼을 플레이어 정보(코스트, 현재 배치 타워 수, HP 등의 정보) 중 코스트에서 감소시키며,
현재 배치 타워 수를 증가시킵니다.   
만약 플레이어가 가진 코스트가 타워의 배치 코스트보다 적거나, 현재 배치된 타워의 수가 가득 찼다면 더 이상 타워를 배치할 수 없습니다.   
   
### 6.4 웨이브 시작과 적 공격
<img src="https://user-images.githubusercontent.com/43777949/193463430-cbd6c475-909f-4fa3-939a-446b6329a9fc.gif" width="100%"/>   
우측 상단의 시작 버튼을 누르면 웨이브가 시작됩니다. 웨이브 정보가 저장된 오브젝트 WaveSystem에서 웨이브 정보를 읽어와
적을 스폰하는 EnemySpawner에서 적을 하나씩 스폰합니다.   
타워의 공격 범위와 적의 **충돌 판정**을 통해 적이 타워의 범위 안에 들어왔는지 판단합니다. 만약 타워의 공격 범위에 적이 들어오면
각 타워가 가진 EnemyList라는 List 자료구조에 적의 정보를 삽입합니다.   
각 타워는 이 List에서 목표지점까지 남은 거리가 가장 짧은 적을 선택하여 이것을 공격할 타겟으로 설정합니다.   
타겟이 정해졌다면 지정된 공격 함수에 따라 타워는 총알을 쏘아 적을 공격합니다. 
총알에 피격된 적은 일시적으로 색이 붉게 변합니다.   
적을 스폰하는 함수, 아군 타워가 적을 타겟팅하고 공격하는 함수는 모두 **코루틴**으로 작성하였습니다.   
   
### 6.5 일시정지
<img src="https://user-images.githubusercontent.com/43777949/193463434-6e6c3e12-cd10-4a11-b52f-a52e386de425.gif" width="100%"/>   
우측 상단의 일시정지 버튼을 누르면 게임이 일시정지됩니다.   
이 상태에서 돌아가기 버튼을 누른다면 다시 게임이 재개되고, 그만두기 버튼을 누른다면 스테이지 선택 화면으로 돌아갑니다.   
만약 그만두기 버튼을 누른다면 진행 중인 스테이지 정보는 삭제되며 저장되지 않습니다.      
   
### 6.6 타워 정보 표시
<img src="https://user-images.githubusercontent.com/43777949/193463436-04a35a9b-23db-4cd2-b697-659a01568679.gif" width="100%"/>   
배치된 타워를 선택한다면 좌측에 타워의 정보가 출력됩니다.   
타워를 다시 클릭하거나, 다른 타워를 클릭한다면 창이 꺼지며, 처분 버튼을 누른다면 해당 타워가 삭제되고 배치 가능 수가 1 감소합니다.   
   
### 6.7. 스테이지 클리어 성공
<img src="https://user-images.githubusercontent.com/43777949/193463441-8e5a5390-242b-49ce-b386-0a4b58eee154.gif" width="100%"/>   
<img src="https://user-images.githubusercontent.com/43777949/193463454-17f0d7b4-09a7-49e9-beec-ca3e872cf7d0.gif" width="100%"/>   
스테이지 종료는 3가지 종류가 있습니다.   
첫 번째는 완벽하게 모든 적을 제거했을 때로, 별 3개의 클리어 평가를 받을 수 있습니다.   
두 번째는 일부 적을 제거했을 때로, 별 2개의 클리어 평가를 받을 수 있습니다.   
두 가지 경우는 스테이지 종료 후 클리어 화면으로 이동하며 좌측에 랜덤으로 스테이지 클리어에 사용한 캐릭터가 나옵니다.   
또한 스테이지를 클리어할 경우 재화를 획득할 수 있습니다.
스테이지를 완벽하게 클리어했는지 아닌지는 스테이지 진입과 마찬가지로 **DontDestroyOnLoad를 사용하여 씬이 전환되어도
정보를 계속 유지**할 수 있도록 했습니다.   
   
### 6.8. 스테이지 클리어 실패
<img src="https://user-images.githubusercontent.com/43777949/193463451-50fb91a8-4aea-48ef-9276-c2862d19a826.gif" width="100%"/>   
적이 도착지점에 도착한다면 화면 전체가 붉게 점멸하며 플레이어의 HP가 1 감소합니다.   
만약 플레이어의 HP가 0이 되었다면 그 즉시 스테이지가 종료되며 실패 문구가 출력됩니다.

## 🎮수정 진행중
#### 📌 최적화
* 클래스 상속 관계 정립   
![클래스상속](https://user-images.githubusercontent.com/43777949/193557224-33dd62f6-ec66-4234-a790-abb621f309ee.png)   
타워마다 존재했던 클래스를 통합하여 부모 클래스를 만들고, 이를 상속받아 타워마다 각기 다른 특성을 가질 수 있도록 수정 중입니다.   
이를 통해 불필요하게 모든 자식 타워의 컴포넌트를 스크립트에서 호출할 필요도 없으며 클래스들의 구조를 한눈에 확인할 수 있어 수정이 용이합니다.
* 오브젝트 간 커플링 줄이기   
기존에는 오브젝트끼리 서로를 알고 있어야 하는 경우가 많아 커플링이 많이 존재하여 코드가 스파게티가 되는 문제가 있었습니다. 유니티의 Event를 사용하여 커플링을 줄이고,
코드의 구조를 보다 일목요연하게 바꾸는 중입니다.
* GC 신경쓰기   
크기가 작은 프로젝트이기 때문에 GC가 성능에 크게 영향을 주지는 않으나, 대형 프로젝트를 고려하여 GC 호출을 최대한 줄이기 위한 최적화를 진행 중입니다.
> 1. Update()에서 GetComponent(), Find() 사용을 줄이고 Start(), Awake() 등으로 이동   
> 2. 캐싱   
> 많은 기능이 코루틴으로 구현되었기 때문에 매번 생성되는 new WaitSeconds 객체 가비지를 줄이기 위해 yield를 캐싱하여 사용합니다. GameObject, transform 등도 캐싱하여 사용하도록 합니다.
> 3. ScriptableObject 사용   
> 스테이지의 데이터는 변하지 않는 고정값이기 때문에 ScriptableObject를 사용하여 스테이지 정보를 지정합니다.
> 4. 오브젝트 풀링   
> 타워를 배치하기 위해 드래그를 하면, 공격은 하지 않는 임시 SD가 Instantiate되고 타워가 배치가 되면 이 임시 SD는 Destroy됩니다.   
> 또, 타워가 생성하는 Bullet 또한 생성과 파괴가 빈번하게 발생합니다.   
> 빈번한 생성과 파괴를 줄이기 위해 이미 임시 SD와 총알들을 생성하는 방식을 사용하도록 합니다.
* List 자료구조 바꾸기   
대부분의 자료구조로 List를 사용했으나, List 이외의 적절한 다른 자료구조를 찾으면 변경할 계획입니다.   

#### 📌 Addressable Asset 사용
* 빌드 타임을 줄이기 위해 Addressable Asset을 사용합니다.
* 서버와 연결하여 업데이트가 있을 경우 서버에서 다운로드 받을 수 있도록 합니다.(구글 드라이브 or AWS 예정)
#### 📌 비동기 프로그래밍 Await/Async
* 로딩창을 만들어 데이터를 다운로드하고, 적용하는 시간을 가집니다.
#### ~📌 스테이지 방식 변경~
~* 배치 위치는 땅과 언덕으로 바꿔 지나가는 적을 저지할 수 있게~   
~* 타워의 종류에 아군을 치료할 수 있는 타워 추가~   
~* 적 또한 아군 타워를 공격할 수 있도록 변경~   
#### 📌 버그 수정
* 편성 화면에서 이미 편성한 캐릭터의 이미지가 출력되는 현상
* 타워를 배치할 때 배치 가능한 위치가 출력되지 않는 현상
